/*-------------------------------------------------------------------------
    String+Char.swift -- String/Character extensions
    Compiler Generator Coco/R
    Copyright (c) by Michael Griebling

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

import Foundation

public extension String {
	
	// Extensions to make it easier to work with C-style strings
	
	public subscript (n: Int) -> Character {
		get {
			let s = self.characters.index(self.characters.startIndex, offsetBy: n)
			if s < self.characters.endIndex {
				return self.characters[s]
			}
			return "\0"
		}
		set {
            let len = self.characters.count
			if n < len {
                let lastCharacters = self.characters.dropFirst(n)
                self.characters = self.characters.dropLast(len-n) + [newValue] + lastCharacters
			}
		}
	}
	
	public func count() -> Int { return self.characters.count }
	
	public func stringByTrimmingTrailingCharactersInSet (_ characterSet: CharacterSet) -> String {
		if let rangeOfLastWantedCharacter = self.rangeOfCharacter(from: characterSet.inverted, options:.backwards) {
			return self.substring(to: rangeOfLastWantedCharacter.upperBound)
		}
		return ""
	}
    
    public func substring (_ from: Int, _ length: Int) -> String {
        let str = self as NSString
        return str.substring(with: NSMakeRange(from, length))
    }
    
    public func contains (_ s: String) -> Bool {
        let str = self as NSString
        return str.contains(s)
    }
    
    public func trim() -> String {
        return self.trimmingCharacters(in: CharacterSet.whitespaces)
    }
	
}

public extension Character {

    public var unicodeValue : Int { return Int(unicodeScalar.value) }
    public var unicodeScalar : UnicodeScalar { return String(self).unicodeScalars.first ?? "\0" }
    
    public func isLetter() -> Bool { return CharacterSet.letters.contains(unicodeScalar) }
    public func isAscii() -> Bool { return unicodeScalar.isASCII }
    
    public func isAlphanumeric() -> Bool { return CharacterSet.alphanumerics.contains(unicodeScalar) }
    
    public var lowercase : Character {
        let s = String(self).lowercased(with: Locale.current)
        return s.characters.first ?? self
    }
	
	init(_ int: Int) { self = Character(UnicodeScalar(int)!) }
	
	public func add (_ n: Int) -> Character { return Character(self.unicodeValue + n) }

    static public func == (l: Int, r: Character) -> Bool { return l == r.unicodeValue }
    static public func == (l: Character, r: Int) -> Bool { return r == l }
    static public func != (l: Int, r: Character) -> Bool { return l != r.unicodeValue }
    static public func != (l: Character, r: Int) -> Bool { return r != l }
    static public func + (c: Character, inc: Int) -> Character { return c.add(inc) }
    static public func - (c: Character, inc: Int) -> Character { return c.add(-inc) }
    static public func - (c: Character, inc: Character) -> Int { return c.add(-inc.unicodeValue).unicodeValue }
    static public func += (c: inout Character, inc: Int) { c = c + inc }
    static public func -= (c: inout Character, inc: Int) { c = c - inc }
    
}
