/*-------------------------------------------------------------------------
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, 2015-2017

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.

    NOTE: The code below has been automatically generated from the
    Parser.frame, Scanner.frame and Coco.atg files.  DO NOT EDIT HERE.
-------------------------------------------------------------------------*/

import Foundation



public class Parser {
	public let _EOF = 0
	public let _ident = 1
	public let _number = 2
	public let _program = 3
	public let _func = 7
	public let _Int = 10
	public let _Bool = 11
	public let _var = 12
	public let _if = 15
	public let _else = 16
	public let _while = 17
	public let _read = 18
	public let _print = 19
	public let _true = 20
	public let _false = 21
	public let maxT = 29

	static let _T = true
	static let _x = false
	static let minErrDist = 2
	let minErrDist : Int = Parser.minErrDist

	public var scanner: Scanner
	public var errors: Errors

	public var t: Token             // last recognized token
	public var la: Token            // lookahead token
	var errDist = Parser.minErrDist

	let undef = 0; let integer = 1; let boolean = 2
	
	// object kinds
	let variable = 0; let proc = 1
	
	public var tab : SymbolTable!
	public var gen : CodeGenerator!
	
	/*--------------------------------------------------------------------------*/
	
	


    public init(scanner: Scanner) {
        self.scanner = scanner
        errors = Errors()
        t = Token()
        la = t
    }
    
    func SynErr (_ n: Int) {
        if errDist >= minErrDist { errors.SynErr(la.line, col: la.col, n: n) }
        errDist = 0
    }
    
    public func SemErr (_ msg: String) {
        if errDist >= minErrDist { errors.SemErr(t.line, col: t.col, s: msg) }
        errDist = 0
    }

	func Get () {
		while true {
            t = la
            la = scanner.Scan()
            if la.kind <= maxT { errDist += 1; break }

			la = t
		}
	}
	
    func Expect (_ n: Int) {
        if la.kind == n { Get() } else { SynErr(n) }
    }
    
    func StartOf (_ s: Int) -> Bool {
        return set(s, la.kind)
    }
    
    func ExpectWeak (_ n: Int, _ follow: Int) {
        if la.kind == n {
			Get()
		} else {
            SynErr(n)
            while !StartOf(follow) { Get() }
        }
    }
    
    func WeakSeparator(_ n: Int, _ syFol: Int, _ repFol: Int) -> Bool {
        var kind = la.kind
        if kind == n { Get(); return true }
        else if StartOf(repFol) { return false }
        else {
            SynErr(n)
            while !(set(syFol, kind) || set(repFol, kind) || set(0, kind)) {
                Get()
                kind = la.kind
            }
            return StartOf(syFol)
        }
    }

	func Taste() {
		var name = "" 
		Expect(_program)
		Ident(&name)
		tab.OpenScope() 
		Expect(4 /* "{" */)
		while la.kind == _func || la.kind == _var {
			if la.kind == _var {
				VarDecl()
				if la.kind == 5 /* ";" */ {
					Get()
				}
			} else {
				ProcDecl()
			}
		}
		Expect(6 /* "}" */)
		tab.CloseScope()
		if gen.progStart == -1 { SemErr("main function never defined") }
		
	}

	func Ident(_ name: inout String) {
		Expect(_ident)
		name = t.val 
	}

	func VarDecl() {
		var name = ""; var type = undef 
		Expect(_var)
		Ident(&name)
		Expect(13 /* ":" */)
		Type(&type)
		_ = tab.NewObj(name, variable, type) 
	}

	func ProcDecl() {
		var name = ""; var obj: Obj; var adr: Int 
		Expect(_func)
		Ident(&name)
		obj = tab.NewObj(name, proc, undef); obj.adr = gen.pc
		if name == "Main" { gen.progStart = gen.pc }
		tab.OpenScope() 
		Expect(8 /* "(" */)
		Expect(9 /* ")" */)
		Expect(4 /* "{" */)
		gen.Emit( .ENTER, 0 ); adr = gen.pc - 2 
		StatSeq()
		Expect(6 /* "}" */)
		gen.Emit( .LEAVE ); gen.Emit( .RET )
		gen.Patch(adr, tab.topScope!.nextAdr)
		tab.CloseScope() 
	}

	func StatSeq() {
		Stat()
		while StartOf(1) {
			if la.kind == 5 /* ";" */ {
				Get()
			}
			Stat()
		}
	}

	func Type(_ type: inout Int) {
		type = undef 
		if la.kind == _Int {
			Get()
			type = integer 
		} else if la.kind == _Bool {
			Get()
			type = boolean 
		} else { SynErr(30) }
	}

	func Stat() {
		var type = undef
		var name = ""
		var obj: Obj
		var adr, adr2, loopstart: Int 
		switch la.kind {
		case _ident: 
			Ident(&name)
			obj = tab.Find(name) 
			if la.kind == 14 /* "=" */ {
				Get()
				if obj.kind != variable { SemErr("cannot assign to procedure") } 
				Expr(&type)
				if type != obj.type { SemErr("incompatible types") }
				if obj.level == 0 { gen.Emit( .STOG, obj.adr ) }
				else { gen.Emit( .STO, obj.adr ) } 
			} else if la.kind == 8 /* "(" */ {
				Get()
				Expect(9 /* ")" */)
				if obj.kind != proc { SemErr("object is not a procedure") }
				gen.Emit( .CALL, obj.adr ) 
			} else { SynErr(31) }
		case _if: 
			Get()
			Expr(&type)
			if type != boolean { SemErr("boolean type expected") }
			gen.Emit( .FJMP, 0 ); adr = gen.pc - 2  
			Expect(4 /* "{" */)
			StatSeq()
			Expect(6 /* "}" */)
			if la.kind == _else {
				Get()
				Expect(4 /* "{" */)
				gen.Emit( .JMP, 0 ); adr2 = gen.pc - 2
				gen.Patch(adr, gen.pc); adr = adr2 
				StatSeq()
				Expect(6 /* "}" */)
			}
			gen.Patch(adr, gen.pc) 
		case _while: 
			Get()
			loopstart = gen.pc 
			Expr(&type)
			if type != boolean { SemErr("boolean type expected") }
			gen.Emit( .FJMP, 0 ); adr = gen.pc - 2 
			Expect(4 /* "{" */)
			StatSeq()
			gen.Emit( .JMP, loopstart ); gen.Patch(adr, gen.pc) 
			Expect(6 /* "}" */)
		case _read: 
			Get()
			Expect(8 /* "(" */)
			Ident(&name)
			Expect(9 /* ")" */)
			obj = tab.Find(name);
			if obj.type != integer { SemErr("integer type expected") }
			gen.Emit( .READ )
			if obj.level == 0 { gen.Emit( .STOG, obj.adr ) }
			else { gen.Emit( .STO, obj.adr ) } 
		case _print: 
			Get()
			Expect(8 /* "(" */)
			Expr(&type)
			Expect(9 /* ")" */)
			if type != integer { SemErr("integer type expected") }
			gen.Emit( .WRITE ) 
		case _var: 
			VarDecl()
		default: SynErr(32)
		}
	}

	func Expr(_ type: inout Int) {
		var type1 = 0; var op = Op.UNDEF 
		SimExpr(&type)
		if la.kind == 26 /* "==" */ || la.kind == 27 /* "<" */ || la.kind == 28 /* ">" */ {
			RelOp(&op)
			SimExpr(&type1)
			if type != type1 { SemErr("incompatible types") }
			gen.Emit(op); type = boolean 
		}
	}

	func SimExpr(_ type: inout Int) {
		var type1 = undef; var op = Op.UNDEF 
		Term(&type)
		while la.kind == 22 /* "-" */ || la.kind == 25 /* "+" */ {
			AddOp(&op)
			Term(&type1)
			if type != integer || type1 != integer { SemErr("integer type expected") }
			gen.Emit(op) 
		}
	}

	func RelOp(_ op: inout Op) {
		op = .EQU 
		if la.kind == 26 /* "==" */ {
			Get()
		} else if la.kind == 27 /* "<" */ {
			Get()
			op = .LSS 
		} else if la.kind == 28 /* ">" */ {
			Get()
			op = .GTR 
		} else { SynErr(33) }
	}

	func Term(_ type: inout Int) {
		var type1 = undef; var op = Op.UNDEF 
		Factor(&type)
		while la.kind == 23 /* "*" */ || la.kind == 24 /* "/" */ {
			MulOp(&op)
			Factor(&type1)
			if type != integer || type1 != integer { SemErr("integer type expected") }
			gen.Emit(op) 
		}
	}

	func AddOp(_ op: inout Op) {
		op = .ADD
		if la.kind == 25 /* "+" */ {
			Get()
		} else if la.kind == 22 /* "-" */ {
			Get()
			op = .SUB
		} else { SynErr(34) }
	}

	func Factor(_ type: inout Int) {
		var n = 0; var obj: Obj; var name = "" 
		type = undef 
		if la.kind == _ident {
			Ident(&name)
			obj = tab.Find(name); type = obj.type
			if obj.kind == variable {
			   if obj.level == 0 { gen.Emit( .LOADG, obj.adr ) }
			   else { gen.Emit( .LOAD, obj.adr ) }
			} else { SemErr("variable expected") } 
		} else if la.kind == _true {
			Get()
			gen.Emit( .CONST, 1 ); type = boolean 
		} else if la.kind == _false {
			Get()
			gen.Emit( .CONST, 0 ); type = boolean 
		} else if la.kind == _number {
			Get()
			n = Int(t.val) ?? 0
			gen.Emit( .CONST, n ); type = integer 
		} else if la.kind == 22 /* "-" */ {
			Get()
			Factor(&type)
			if type != integer { SemErr("integer type expected"); type = integer }
			gen.Emit( .NEG ) 
		} else { SynErr(35) }
	}

	func MulOp(_ op: inout Op) {
		op = .MUL 
		if la.kind == 23 /* "*" */ {
			Get()
		} else if la.kind == 24 /* "/" */ {
			Get()
			op = .DIV 
		} else { SynErr(36) }
	}



    public func Parse() {
        la = Token()
        la.val = ""
        Get()
		Taste()
		Expect(_EOF)

	}

    func set (_ x: Int, _ y: Int) -> Bool { return Parser._set[x][y] }
    static let _set: [[Bool]] = [
		[_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x],
		[_x,_T,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _T,_x,_x,_T, _x,_T,_T,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x]

	]
} // end Parser


public class Errors {
    public var count = 0                                 // number of errors detected
    private let errorStream = Darwin.stderr              // error messages go to this stream
    public var errMsgFormat = "-- line %i col %i: %@"    // 0=line, 1=column, 2=text
    
    func Write(_ s: String) { fputs(s, errorStream) }
    func WriteLine(_ format: String, line: Int, col: Int, s: String) {
        let str = String(format: format, line, col, s)
        WriteLine(str)
    }
    func WriteLine(_ s: String) { Write(s + "\n") }
    
    public func SynErr (_ line: Int, col: Int, n: Int) {
        var s: String
        switch n {
		case 0: s = "EOF expected"
		case 1: s = "ident expected"
		case 2: s = "number expected"
		case 3: s = "\"program\" expected"
		case 4: s = "\"{\" expected"
		case 5: s = "\";\" expected"
		case 6: s = "\"}\" expected"
		case 7: s = "\"func\" expected"
		case 8: s = "\"(\" expected"
		case 9: s = "\")\" expected"
		case 10: s = "\"Int\" expected"
		case 11: s = "\"Bool\" expected"
		case 12: s = "\"var\" expected"
		case 13: s = "\":\" expected"
		case 14: s = "\"=\" expected"
		case 15: s = "\"if\" expected"
		case 16: s = "\"else\" expected"
		case 17: s = "\"while\" expected"
		case 18: s = "\"read\" expected"
		case 19: s = "\"print\" expected"
		case 20: s = "\"true\" expected"
		case 21: s = "\"false\" expected"
		case 22: s = "\"-\" expected"
		case 23: s = "\"*\" expected"
		case 24: s = "\"/\" expected"
		case 25: s = "\"+\" expected"
		case 26: s = "\"==\" expected"
		case 27: s = "\"<\" expected"
		case 28: s = "\">\" expected"
		case 29: s = "??? expected"
		case 30: s = "invalid Type"
		case 31: s = "invalid Stat"
		case 32: s = "invalid Stat"
		case 33: s = "invalid RelOp"
		case 34: s = "invalid AddOp"
		case 35: s = "invalid Factor"
		case 36: s = "invalid MulOp"

        default: s = "error \(n)"
        }
        WriteLine(errMsgFormat, line: line, col: col, s: s)
        count += 1
	}

    public func SemErr (_ line: Int, col: Int, s: String) {
        WriteLine(errMsgFormat, line: line, col: col, s: s);
        count += 1
    }
    
    public func SemErr (_ s: String) {
        WriteLine(s)
        count += 1
    }
    
    public func Warning (_ line: Int, col: Int, s: String) {
        WriteLine(errMsgFormat, line: line, col: col, s: s)
    }
    
    public func Warning(_ s: String) {
        WriteLine(s)
    }
} // Errors

